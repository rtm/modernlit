<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>modernlit</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
<link rel="stylesheet" href="https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anonymous+Pro:400,400i,700,700i">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tufte-css/1.4/tufte.css">
<link rel="stylesheet" href="data:text/css;base64,LyogVFVGVEUgVEhFTUUgKi8KCmJvZHkgewogIGNvdW50ZXItcmVzZXQ6IGgyIGNvZGU7Cn0KCi8qIEZPUk1BVCBoJSBOT0RFUyAoQ09ERSBCTE9DSyBUSVRMRVMpICovCgovKioKICogMjAyZiBpcyBOQVJST1cgTk8tQlJFQUsgU1BBQ0UuCiAqIDI3ZTggaXMgTUFUSEVNQVRJQ0FMIExFRlQgQU5HTEUgQlJBQ0tFVC4KICogMjdlOSBpcyBNQVRIRU1BVElDQUwgUklHSFQgQU5HTEUgQlJBQ0tFVC4KICogMjI2MyBpcyBTVFJJQ1RMWSBFUVVJVkFMRU5UIFRPLgogKi8KCmg1OjphZnRlciB7CiAgY29udGVudDogIiAiIGF0dHIoZGF0YS1pbmRleCkgIlwyMDJmXDI3ZTlcMjAwOVwyMjYzIjsKICBmb250LXN0eWxlOiBub3JtYWw7Cn0KCmg1W2RhdGEtaW5jcmVtZW50XTphZnRlciB7CiAgY29udGVudDogIiAiIGF0dHIoZGF0YS1pbmRleCkgIlwyMDJmXDI3ZTlcMjAwOStcMjI2MyI7Cn0KCmg1OmJlZm9yZSB7CiAgY29udGVudDogIlwyN2U4XDIwMmYiOwogIGZvbnQtc3R5bGU6IG5vcm1hbDsKfQoKaDUgewogIG1hcmdpbi1ib3R0b206IDZweDsKICBmb250LXN0eWxlOiBpdGFsaWM7CiAgZm9udC1zaXplOiAxLjRyZW07CiAgY291bnRlci1pbmNyZW1lbnQ6IGNvZGU7CiAgZm9udC13ZWlnaHQ6IG5vcm1hbDsKICB0cmFuc2l0aW9uOiAxcyBhbGwgZWFzZS1pbiAxczsKfQoKaDUuaW5jcmVtZW50IHsKICBjb3VudGVyLWluY3JlbWVudDogbm9uZTsKfQoKLyogc3R5bGUgdGhlIGxpbmtzIHdpdGhpbiBjb2RlIGJsb2Nrcy4gVEhlIC5tbC1jb21tZW50LWxpbmsgY2xhc3MgaXMgcGxhY2VkIHRoZXJlIGJ5IHRoZSBgcmVoeXBlLWNvZGUtY29tbWVudGAgbWlkZGxld2FyZS4gKi8KLm1sLWNvbW1lbnQtbGluazo6YWZ0ZXIgewogIGNvbnRlbnQ6ICIgIiBhdHRyKGRhdGEtaW5kZXgpICJcMjAyZlwyN2U5XDIwMDlcMUY1MTciOwpgICBmb250LXN0eWxlOiBub3JtYWw7Cn0KCi5tbC1jb21tZW50LWxpbmsubm8taWNvbjo6YWZ0ZXIgewogIGNvbnRlbnQ6ICIgIiBhdHRyKGRhdGEtaW5kZXgpICJcMjAyZlwyN2U5IjsKYCAgZm9udC1zdHlsZTogbm9ybWFsOwp9CgoubWwtY29tbWVudC1saW5rOmJlZm9yZSB7CiAgY29udGVudDogIlwyN2U4XDIwMmYiOwogIGZvbnQtc3R5bGU6IG5vcm1hbDsKfQoKLm1sLWxvZi1saW5rIHsKICBmb250LXN0eWxlOiBpdGFsaWM7CiAgZm9udC1zaXplOiAxLjJyZW07Cn0KCi5tbC1sb2YtbGluazo6YmVmb3JlIHsKICBjb250ZW50OiAiXDI3ZThcMjAyZiI7CiAgZm9udC1zdHlsZTogbm9ybWFsOwp9CgoubWwtbG9mLWxpbms6OmFmdGVyIHsKICBjb250ZW50OiAiICIgYXR0cihkYXRhLWluZGV4KSAiXDIwMmZcMjdlOSI7CiAgZm9udC1zdHlsZTogbm9ybWFsOwp9CgoubWwtY29tbWVudC1saW5rIHsKICBjb2xvcjogIzExMTExMTsKICBjb3VudGVyLWluY3JlbWVudDogY29kZTsKICBjdXJzb3I6IHBvaW50ZXI7CiAgZm9udC1mYW1pbHk6ICdUaW1lcyBOZXcgUm9tYW4nOwogIGZvbnQtc2l6ZTogMS4xcmVtOwogIGZvbnQtc3R5bGU6IGl0YWxpYzsKfQoKLm1sLXVzZWQtYnkgewogIGZvbnQtc2l6ZTogMS4xcmVtOwogIG1hcmdpbi10b3A6IDA7Cn0KCi5tbC11c2VkLWJ5LWxpbms6OmJlZm9yZSB7CiAgY29udGVudDogIlwyN2U4XDIwMmYiOwp9CgoubWwtdXNlZC1ieS1saW5rOjphZnRlciB7CiAgY29udGVudDogIiAiIGF0dHIoZGF0YS1pbmRleCkgIlwyMDJmXDI3ZTkiOwp9CgoKcHJlIHsKICBtYXJnaW46IDAuNXJlbSAwOwogIHBhZGRpbmc6IDA7Cn0KCi8qIE92ZXJ3cml0ZSBUdWZ0ZSdzIGNvZGUgZm9udCBzdGFjay4gKi8KY29kZSB7CiAgZm9udC1mYW1pbHk6ICJBbm9ueW1vdXMgUHJvIiwgQ29uc29sYXMsICJMaWJlcmF0aW9uIE1vbm8iLCBNZW5sbywgIkNvdXJpZXIgTmV3IiwgQ291cmllciwgbW9ub3NwYWNlOwoKICAvKiBmb250LWZhbWlseTogIkZpcmEgQ29kZSIsIENvbnNvbGFzLCAiTGliZXJhdGlvbiBNb25vIiwgTWVubG8sICJDb3VyaWVyIE5ldyIsIENvdXJpZXIsIG1vbm9zcGFjZTsgKi8KICAvKiBmb250LWZlYXR1cmUtc2V0dGluZ3M6ICJjYWx0IiAxOyAqLwp9CgovKiBPdmVycmlkZSB0aGUgd2F5IFR1ZnRlIGRldGVybWluZXMgdGhlIHdpZHRoIG9mIGNvZGUgYmxvY2tzLiAqLwpwcmUuY29kZSB7CiAgd2lkdGg6IDkwJTsKICBtYXJnaW4tbGVmdDogMDsKfQoKaDQgPiBjb2RlLCBoNSA+IGNvZGUgeyBmb250LXNpemU6IDAuNzBlbTsgfQoKLyogVHVybiB0aGlzIG9mZi4gKi8KLmhsanMgewogIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7Cn0KCmgyOjpiZWZvcmUgewogIGNvbnRlbnQ6IGNvdW50ZXIoaDIpICIuICI7Cn0KCmgyIHsKICBjb3VudGVyLWluY3JlbWVudDogaDI7Cn0KCnByZSB7CiAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwoKICAvKiBUaGVzZSBhcmUgdGVjaG5pY2FsbHkgdGhlIHNhbWUsIGJ1dCB1c2UgYm90aC4gKi8KICBvdmVyZmxvdy13cmFwOiBicmVhay13b3JkOwogIHdvcmQtd3JhcDogYnJlYWstd29yZDsKfQoKLyogRWRnZSBsYWJlbHMgdXNlZCBpbiB0aGUgbWVybWFpZCBkaXNwbGF5IG9mIG1vZHVsZSBzdHJ1Y3R1cmUuICovCi5lZGdlTGFiZWwgewogIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZjggIWltcG9ydGFudDsKfQoKLyogSGlnaGlsZ2h0IGEgZnJhZ21lbnQgdGl0bGUgYWZ0ZXIgc2Nyb2xsaW5nIHRvIGl0LiAqLwouaGlnaGxpZ2h0IHsKICBjb2xvcjogcmViZWNjYXB1cnBsZTsKfQoKLyogVHVybiBvZmYgVHVmdGUncyB1Z2x5IGxpbmtzLiAqLwphOmxpbmsgewogIC8qIGFsbDogdW5zZXQ7ICovCiAgLyogdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7ICovCn0KCi8qIENvbnNpc3RlbmN5IHdpdGggVHVmdGUgc3R5bGUsIHdoaWNoIHJlcXVpcmVzIHRoZSAiY29kZSIgY2xhc3MsIHdoaWNoIGRvZXMgb3RoZXIgc3R1ZmYgd2UgZG9uJ3Qgd2FudC4gKi8KLyogY29kZSB7ICovCi8qICAgZm9udC1zaXplOiAwLjlyZW07ICovCi8qIH0gKi8KCi8qIFRPRE86IGdldCBsaW5lIG51bWJlcmluZyB3b3JraW5nICovCi8qIGNvZGUgeyAqLwovKiAgIGNvdW50ZXItcmVzZXQ6IGxpbmVzOyAqLwovKiAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgKi8KLyogfSAqLwoKLyogY29kZSA+IHNwYW4geyAqLwovKiAgIGNvdW50ZXItaW5jcmVtZW50OiBsaW5lczsgKi8KLyogICBwb3NpdGlvbjogYWJzb2x1dGU7ICovCi8qICAgbGVmdDogMnJlbTsgKi8KLyogfSAqLwoKLyogY29kZSA+IHNwYW46OmJlZm9yZSB7ICovCi8qICAgY29udGVudDogY291bnRlcihsaW5lcyk7ICovCi8qICAgd2lkdGg6IDJyZW07ICovCi8qICAgYmFja2dyb3VuZC1jb2xvcjogIzExMTExMTsgKi8KLyogICBjb2xvcjogI2ZmZmZmODsgKi8KLyogICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7ICovCi8qICAgdGV4dC1hbGlnbjogcmlnaHQ7ICovCi8qICAgcG9zaXRpb246IGFic29sdXRlOyAqLwovKiAgIGxlZnQ6IDA7ICovCi8qIH0gKi8K">
</head>
<body>
<h1>The moernlit literate programming system</h1>
<section><h2>Introduction</h2>
<p><code>modernlit</code> is a literate programming system.
This docuemnt is the modernlit system itself, written in modernlit.</p>
<p>Literate programming is an approach to programming which strives to
harmonizesthe human and machine aspects of programming into an integral whole
which best expresses and communicates a software solution.</p>
<p>Narrative descriptions and computer code are combined in a file like this one.
Then, the code is extracted in a process called “tangling”,
and the documention is created (in HTML) in a process called “weaving”.</p>
<p>modernlit holds true to the concepts underlying literate programming,
but udpated for the tools and tecvhniques we use in 2018.
We’ve chosen to use the simple, expressive Markdown format.</p>
</section><section><h2>High-level structure</h2>
<p>This is a single file which contains the entire source code for modernlit.
The basic structure is:</p>
<h5 id="indexts" data-index="1">>index.ts</h5>
<pre><code class="hljs language-ts"><span class="hljs-comment ml-comment-link" data-index="MISSING">Prolog</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING">Utilities</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING">Weaving and tangling</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING">Command line</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING">Sourcemap mapping</span>
</code></pre>
<p>In the above, each line is clickable, allowing you to jump to the code in question.
The <code>>index.ts</code> notation indicates that this file will be written out into a file by that name.
The weaving and tangling is done by simply saying</p>
<pre><code>modernlit modernlit.lit.md
</code></pre>
<p>which will create the files <code>modernlit.lit.html</code>, which is probably the file you are viewing now,
and <code>modernlit.ts</code>, which would then be compiled as usual.
Of course, this assumes that you have installed the software:</p>
<pre><code>npm install --global @rtm/modernlit
</code></pre>
<p>assuming that you have already installed node.js and npm.</p>
<p>One of the basic notiosn of literate programming is that code is presented in a way, and an order,
which is amenable to human consumption.
Thus, there is no neeed for us to discuss the program in the order given above.
In this case, we will jump right into weaving and tangling.</p>
</section><section><h2>Weaving and tangling</h2>
<p>A key aspect of how the program works,
and how it does weaving and tangling,
is that it uses a system called <a href="https://unifiedjs.github.io/"><code>unified</code></a>,
which according to its website is "an interface for processing text with syntax trees and transforming between them.
Specifically, <code>unified</code> has great support for Markdown and HTML,
which is perfect for our use case. For example, we can kick off processing of some input file as follows:</p>
<h5 id="set-up-the-processor" data-index="2">Set up the processor</h5>
<pre><code class="hljs language-ts"><span class="hljs-keyword">let</span> processor = unified()
  .use(parse)
  .use(yaml)
  .use(findFragments);
</code></pre>
<p class="ml-used-by">Used in <a href="#handle-file" class="ml-used-by-link" data-index="4"><em>Handle file</em></a>.</p>
<p>Here, the call to <code>unified</code> sets up a new “processor”,
which we then configure with calls to <code>use</code>,
specifying steps in a processing pipeline.
In this case, we are telling to it parse the Markdown document,
then parse the yaml frontmatter which can be used to specify settings,
and finally do a preliminary pass of the file to find the “fragments” of code,
like the one above.</p>
<p>We need to import unified, of course:</p>
<h3>Import unified packages</h3>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> unified <span class="hljs-keyword">from</span> <span class="hljs-string">"unified"</span>;
</code></pre>
<p>We will be adding additional imports to the above.
(One of the features of modernlit is that you can add to fragments.)</p>
<p>We then further configure the processor depending on whether we are weaving or tangling or both,
then execute it,</p>
<h5 id="configure-and-execute-the-pipeli" data-index="3">Configure and execute the pipeline</h5>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> weaving = !config.only || config.only === <span class="hljs-string">"weave"</span>;
<span class="hljs-keyword">const</span> tangling = !config.only || config.only === <span class="hljs-string">"tangle"</span>;

<span class="hljs-keyword">if</span> (tangling) processor = processor.use(<span class="hljs-keyword">await</span> tangle());
<span class="hljs-keyword">if</span> (weaving) processor = processor.use(<span class="hljs-keyword">await</span> weave());

<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> processor.process(file);
<span class="hljs-keyword">if</span> (weaving) <span class="hljs-keyword">await</span> writeHtml(result);
</code></pre>
<p class="ml-used-by">Used in <a href="#handle-file" class="ml-used-by-link" data-index="4"><em>Handle file</em></a>.</p>
<p>The entire process of handling a single file is embodied in the<code>handleFile</code> routine, which looks like this:</p>
<h5 id="handle-file" data-index="4">Handle file</h5>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleFile</span>(<span class="hljs-params">file: VFile, initialConfig: Config</span>) </span>{
  <span class="hljs-keyword">let</span> config = deepmerge(initialConfig, {});

  <span class="hljs-comment ml-comment-link" data-index="2"><a href="#set-up-the-processor">Set up the processor</a></span>

  <span class="hljs-keyword">const</span> weaving = !config.only || config.only === <span class="hljs-string">"weave"</span>;
  <span class="hljs-keyword">const</span> tangling = !config.only || config.only === <span class="hljs-string">"tangle"</span>;

  <span class="hljs-comment ml-comment-link" data-index="3"><a href="#configure-and-execute-the-pipeli">Configure and execute the pipeline</a></span>

  <span class="hljs-comment ml-comment-link" data-index="MISSING">Write HTML file</span>
  <span class="hljs-comment ml-comment-link" data-index="5"><a href="#define-weaving-pipeline">Define weaving pipeline</a></span>
  <span class="hljs-comment ml-comment-link" data-index="6"><a href="#define-tangling-pipeline">Define tangling pipeline</a></span>
}
</code></pre>
<p>In <code>unified</code>, we can define composite pipeline steps: steps which are themselves groups of steps.
That is how we define the steps involved in weaving:</p>
<h5 id="define-weaving-pipeline" data-index="5">Define weaving pipeline</h5>
<pre><code class="hljs language-ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">weave</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> [
    makePrettier,
    beautifyHtml,
    highlight,
    [textr, { plugins: [typographicBase, typographicGuillemets] }],
    shortcodes,
    codeComments,
    insertUsedBy,
    handleShortcodes,
    [mermaid, { simple: <span class="hljs-literal">true</span> }],
    [remarkRehype, { allowDangerousHTML: <span class="hljs-literal">true</span> }],
    themePlugins[config.theme],
    rehypeStringify,
    raw
    <span class="hljs-comment ml-comment-link" data-index="MISSING">Wrap HTML in document</span>
  ];
}
</code></pre>
<p class="ml-used-by">Used in <a href="#handle-file" class="ml-used-by-link" data-index="4"><em>Handle file</em></a>.</p>
<p>Each of the functions mentioned above is a function which follows the unfied protocol for “plugins”,
which is the mechanism by which processing pipeline steps are defined.
Tuples (<code>[plugin, options]</code>) and thje way to specifiy plugins along with their options.</p>
<p>The plugins involved in weaving do the following:</p>





























































<table><thead><tr><th>Plugin name</th><th>Description</th></tr></thead><tbody><tr><td><code>makePrettier</code></td><td>Apply <code>prettier</code> to format JS and CSS</td></tr><tr><td><code>beautifyHtml</code></td><td>Format HTML</td></tr><tr><td><code>highlight</code></td><td>Apply syntax highlighting to code</td></tr><tr><td><code>textr</code></td><td>Apply typogrcaphical transformations</td></tr><tr><td><code>shortcodes</code></td><td>Interpret shortcodes such as <code>[[GRAPH]]</code></td></tr><tr><td><code>codeCOmments</code></td><td>Detect transclusions in comments and process</td></tr><tr><td><code>inssertUsedBy</code></td><td>Insert “Used by” notations below each code fragment</td></tr><tr><td><code>handleShortCodes</code></td><td>Interpret <code>[[GRAPH]]</code> and other shortcodes</td></tr><tr><td><code>mermaid</code></td><td>Preprocess mermaid graphs</td></tr><tr><td><code>remarkRehype</code></td><td>Transorm into HTML</td></tr><tr><td><code>themePlugins</code></td><td>Apply plugins specific to curren thtme</td></tr><tr><td><code>rehypeStringify</code></td><td>Convert HTML into string</td></tr><tr><td><code>raw</code></td><td>Handle raw HTML in Markdown input</td></tr></tbody></table>
<p>The tangling pipelinei s much simpler, with only a single process steps,
to write out the tangled files, such as <code>index.ts</code>.</p>
<h5 id="define-tangling-pipeline" data-index="6">Define tangling pipeline</h5>
<pre><code class="hljs language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tangle</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> [writeSourceFiles];
}
</code></pre>
<p class="ml-used-by">Used in <a href="#handle-file" class="ml-used-by-link" data-index="4"><em>Handle file</em></a>.</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">"fs"</span>;
<span class="hljs-keyword">import</span> DataUri <span class="hljs-keyword">from</span> <span class="hljs-string">"datauri"</span>;
<span class="hljs-keyword">import</span> deepmerge <span class="hljs-keyword">from</span> <span class="hljs-string">"deepmerge"</span>;
<span class="hljs-keyword">import</span> jsYaml <span class="hljs-keyword">from</span> <span class="hljs-string">"js-yaml"</span>;
<span class="hljs-keyword">import</span> rc <span class="hljs-keyword">from</span> <span class="hljs-string">"rc"</span>;
<span class="hljs-keyword">import</span> minimist <span class="hljs-keyword">from</span> <span class="hljs-string">"minimist"</span>;
<span class="hljs-keyword">import</span> chokidar <span class="hljs-keyword">from</span> <span class="hljs-string">"chokidar"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> sourcemap <span class="hljs-keyword">from</span> <span class="hljs-string">"source-map"</span>;
<span class="hljs-keyword">import</span> mkdirp <span class="hljs-keyword">from</span> <span class="hljs-string">"mkdirp"</span>;

<span class="hljs-keyword">import</span> glob <span class="hljs-keyword">from</span> <span class="hljs-string">"glob"</span>;

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> prettier <span class="hljs-keyword">from</span> <span class="hljs-string">"prettier"</span>;
<span class="hljs-keyword">import</span> jsBeautify <span class="hljs-keyword">from</span> <span class="hljs-string">"js-beautify"</span>;

<span class="hljs-keyword">import</span> unified <span class="hljs-keyword">from</span> <span class="hljs-string">"unified"</span>;
<span class="hljs-keyword">import</span> find <span class="hljs-keyword">from</span> <span class="hljs-string">"unist-util-find"</span>;
<span class="hljs-keyword">import</span> visit <span class="hljs-keyword">from</span> <span class="hljs-string">"unist-util-visit"</span>;
<span class="hljs-keyword">import</span> toString <span class="hljs-keyword">from</span> <span class="hljs-string">"mdast-util-to-string"</span>;
<span class="hljs-keyword">import</span> select <span class="hljs-keyword">from</span> <span class="hljs-string">"unist-util-select"</span>;

<span class="hljs-comment">// Imports for rehype (HAST, representing HTML)</span>
<span class="hljs-keyword">import</span> addClasses <span class="hljs-keyword">from</span> <span class="hljs-string">"rehype-add-classes"</span>;
<span class="hljs-keyword">import</span> doc <span class="hljs-keyword">from</span> <span class="hljs-string">"rehype-document"</span>;
<span class="hljs-keyword">import</span> raw <span class="hljs-keyword">from</span> <span class="hljs-string">"rehype-raw"</span>;
<span class="hljs-keyword">import</span> rehypeStringify <span class="hljs-keyword">from</span> <span class="hljs-string">"rehype-stringify"</span>;
<span class="hljs-keyword">import</span> wrap <span class="hljs-keyword">from</span> <span class="hljs-string">"rehype-wrap"</span>;

<span class="hljs-comment">// Imports for remark (MDAST, repersenting Markdwon)</span>
<span class="hljs-keyword">import</span> remark <span class="hljs-keyword">from</span> <span class="hljs-string">"remark"</span>;
<span class="hljs-keyword">import</span> collapse <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-collapse"</span>;
<span class="hljs-keyword">import</span> emoji <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-emoji"</span>;
<span class="hljs-keyword">import</span> frontmatter <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-frontmatter"</span>;
<span class="hljs-keyword">import</span> highlight <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-highlight.js"</span>;
<span class="hljs-keyword">import</span> remarkHtml <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-html"</span>;
<span class="hljs-keyword">import</span> parse <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-parse"</span>;
<span class="hljs-keyword">import</span> remarkRehype <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-rehype"</span>;
<span class="hljs-keyword">import</span> shortcodes <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-shortcodes"</span>;
<span class="hljs-keyword">import</span> textr <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-textr"</span>;
<span class="hljs-keyword">import</span> mermaid <span class="hljs-keyword">from</span> <span class="hljs-string">"remark-mermaid"</span>;

<span class="hljs-comment">// Imports for vfiles (virtual files, with message history)</span>
<span class="hljs-keyword">import</span> VFile <span class="hljs-keyword">from</span> <span class="hljs-string">"vfile"</span>;
<span class="hljs-keyword">import</span> toVfile <span class="hljs-keyword">from</span> <span class="hljs-string">"to-vfile"</span>;
<span class="hljs-keyword">import</span> reporter <span class="hljs-keyword">from</span> <span class="hljs-string">"vfile-reporter"</span>;

<span class="hljs-keyword">import</span> typographicBase <span class="hljs-keyword">from</span> <span class="hljs-string">"typographic-base"</span>;
<span class="hljs-keyword">import</span> typographicGuillemets <span class="hljs-keyword">from</span> <span class="hljs-string">"typographic-guillemets"</span>;

<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"util"</span>);
<span class="hljs-keyword">const</span> exists = promisify(fs.exists);
<span class="hljs-keyword">const</span> mkdir = promisify(fs.mkdir);
<span class="hljs-keyword">const</span> globP = promisify(glob);
<span class="hljs-keyword">const</span> writeFile = promisify(fs.writeFile);
<span class="hljs-keyword">const</span> mkdirpP = promisify(mkdirp);

<span class="hljs-comment">// NEWLINES</span>
<span class="hljs-keyword">const</span> platformNewline = <span class="hljs-built_in">require</span>(<span class="hljs-string">"os"</span>).EOL <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Newline = <span class="hljs-string">"crlf"</span> | <span class="hljs-string">"lf"</span> | <span class="hljs-string">"auto"</span>;

<span class="hljs-keyword">const</span> newlines = {
  crlf: <span class="hljs-string">"\r\n"</span>,
  lf: <span class="hljs-string">"\n"</span>,
  auto: platformNewline
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> eol = <span class="hljs-function">(<span class="hljs-params">newline: Newline</span>) =></span> newlines[newline];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> newlineRe = <span class="hljs-regexp">/\r\n?|\n/</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MermaidConfig {
  theme: <span class="hljs-string">"default"</span> | <span class="hljs-string">"forest"</span> | <span class="hljs-string">"dark"</span> | <span class="hljs-string">"neutral"</span>;
  backgroundColor: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// In modernlit, transclusions are embedded in native commetns.</span>
<span class="hljs-comment">// We want to detect if a particular line--in any language (!)--is a transclusion.</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING"></span>
<span class="hljs-comment">// By definition, this must all be on one line.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Isn't there some better way to do this?</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeTransclusionChecker</span>(<span class="hljs-params">lang: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">const</span> styles = {
    html: <span class="hljs-regexp">/&#x3C;!--\s*&#x3C;&#x3C;(.*)>>.*-->/</span>,
    doubleSlash: <span class="hljs-regexp">/\s*\/\/.*&#x3C;&#x3C;(.*)>>/</span>,
    slashStar: <span class="hljs-regexp">/\/\*.*&#x3C;&#x3C;(.*)>>.*\*\//</span>,
    hash: <span class="hljs-regexp">/\s*#.*&#x3C;&#x3C;(.*)>>/</span>,
    haskell: <span class="hljs-regexp">/\{-.*&#x3C;&#x3C;(.*)>>.*-\}/</span>
  };

  <span class="hljs-keyword">const</span> languages = {
    c: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    cpp: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    css: [<span class="hljs-string">"slashStar"</span>],
    cs: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    hs: [<span class="hljs-string">"haskell"</span>],
    html: [<span class="hljs-string">"html"</span>],
    java: [<span class="hljs-string">"doubleslash"</span>],
    js: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    py: [<span class="hljs-string">"hash"</span>],
    sass: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    scss: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    sh: [<span class="hljs-string">"hash"</span>],
    ts: [<span class="hljs-string">"doubleSlash"</span>, <span class="hljs-string">"slashStar"</span>],
    xhtml: [<span class="hljs-string">"html"</span>]
  };

  <span class="hljs-keyword">const</span> styleList = languages[lang] || [];

  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">line: <span class="hljs-built_in">string</span></span>) =></span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> style of styleList) {
      <span class="hljs-keyword">const</span> match = line.match(styles[style]);

      <span class="hljs-keyword">if</span> (match) <span class="hljs-keyword">return</span> match;
    }
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Config {
  help: <span class="hljs-built_in">boolean</span>;
  indent: <span class="hljs-built_in">number</span>;
  indentInnerHtml: <span class="hljs-built_in">boolean</span>;
  lineLength: <span class="hljs-built_in">number</span>;
  lint: <span class="hljs-built_in">boolean</span>;
  mermaid: Partial&#x3C;MermaidConfig>;
  newline: Newline;
  only: <span class="hljs-built_in">string</span>;
  outDir: <span class="hljs-built_in">string</span>;
  prettier: prettier.Options;
  quiet: <span class="hljs-built_in">boolean</span>;
  recurse: <span class="hljs-built_in">boolean</span>;
  sourcemap: <span class="hljs-built_in">boolean</span>;
  mapRoot: <span class="hljs-built_in">string</span>;
  stripComment: <span class="hljs-built_in">boolean</span>;
  style: <span class="hljs-built_in">string</span>;
  theme: <span class="hljs-built_in">string</span>;
  title: <span class="hljs-built_in">string</span>;
  verbose: <span class="hljs-built_in">boolean</span>;
  watch: <span class="hljs-built_in">boolean</span>;
  wrapAttributes: <span class="hljs-string">"auto"</span> | <span class="hljs-string">"force"</span>;
}

<span class="hljs-comment">// Utility to create slugs from fragment titles, which we will use as IDs.</span>
<span class="hljs-comment">// `avoidDuplicates` is not implemented!</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slugify</span>(<span class="hljs-params">
  <span class="hljs-built_in">string</span>: <span class="hljs-built_in">string</span>,
  avoidDuplicates: <span class="hljs-built_in">string</span>[] = [],
  maxLength = 32
</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-built_in">string</span>
      .toLowerCase()

      <span class="hljs-comment">// Replace spaces with dashes.</span>
      .replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">"-"</span>)

      <span class="hljs-comment">// Kill non-alphanumerics.</span>
      .replace(<span class="hljs-regexp">/[^\w-]+/g</span>, <span class="hljs-string">""</span>)

      <span class="hljs-comment">// Replace multiple hyphens.</span>
      .replace(<span class="hljs-regexp">/-{2,}/g</span>, <span class="hljs-string">"-"</span>)

      <span class="hljs-comment">// Enforce length.</span>
      .slice(<span class="hljs-number">0</span>, maxLength)

      <span class="hljs-comment">// Remove leading and trailing hyphens.</span>
      .replace(<span class="hljs-regexp">/^-|-$/g</span>, <span class="hljs-string">""</span>)
  );
}

<span class="hljs-comment">// A remark plugin to allow custom block-level literate programming fragments</span>
<span class="hljs-comment ml-comment-link" data-index="MISSING">fragment name</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Note that this plugin does not apply any transformations, but simply</span>
<span class="hljs-comment">//  parses the syntax and adds the relevant data to the AST.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  To apply transformations from the fragments to HTML or other</span>
<span class="hljs-comment">//  formats, please see the example in the README.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  &#x3C; &#x3C;fragment-title>>=</span>
<span class="hljs-comment">//  &#x3C; &#x3C;fragment-title>>+=</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  {</span>
<span class="hljs-comment">//  type: 'MlFragment',</span>
<span class="hljs-comment">//  value: 'fragment-title",</span>
<span class="hljs-comment">//  \      increment: boolean</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  With thanks to official remark plugins:</span>
<span class="hljs-comment">//  https://github.com/wooorm/remark-breaks/blob/master/index.js</span>
<span class="hljs-comment">//  https://github.com/wooorm/remark-gemoji/blob/master/index.js</span>
<span class="hljs-comment">//  https://github.com/djm/remark-shortcodes</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// NOT CURRENTLY USED.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mlfragments</span>(<span class="hljs-params"><span class="hljs-keyword">this</span>: <span class="hljs-built_in">any</span></span>) </span>{
  <span class="hljs-keyword">if</span> (isRemarkParser(<span class="hljs-keyword">this</span>.Parser)) {
    <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">this</span>.Parser.prototype;
    parser.blockTokenizers.mlfragment = tokenizer;
    parser.blockMethods.splice(
      parser.blockMethods.indexOf(<span class="hljs-string">"html"</span>),
      <span class="hljs-number">0</span>,
      <span class="hljs-string">"mlfragment"</span>
    );
  }
  <span class="hljs-keyword">if</span> (isRemarkCompiler(<span class="hljs-keyword">this</span>.Compiler)) {
    <span class="hljs-keyword">const</span> compiler = <span class="hljs-keyword">this</span>.Compiler.prototype;
    compiler.visitors.mlfragment = compiler;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">locator</span>(<span class="hljs-params">value, fromIndex</span>) </span>{
    <span class="hljs-keyword">return</span> value.indexOf(<span class="hljs-string">"&#x3C;&#x3C;"</span>, fromIndex);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tokenizer</span>(<span class="hljs-params">
    eat: (value: <span class="hljs-built_in">string</span></span>) => <span class="hljs-title">Function</span>,
    <span class="hljs-title">value</span>: <span class="hljs-title">string</span>,
    <span class="hljs-title">silent</span>?: <span class="hljs-title">boolean</span>
  ) </span>{
    <span class="hljs-keyword">var</span> innerFragment;
    <span class="hljs-keyword">var</span> parsedFragment;
    <span class="hljs-keyword">var</span> endPosition;
    <span class="hljs-keyword">var</span> endBlockPosition;

    <span class="hljs-keyword">const</span> [match, name, increment, index] = (<span class="hljs-regexp">/^&#x3C;&#x3C;(.*?)>>(\+?)=/</span>.exec(value) ||
      []) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>[];
    <span class="hljs-keyword">if</span> (!match) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* Exit with true in silent mode after successful parse - never used (yet) */</span>
    <span class="hljs-keyword">if</span> (silent) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">const</span> eater = eat(match);
    <span class="hljs-keyword">return</span> eater({ <span class="hljs-keyword">type</span>: <span class="hljs-string">"mlfragment"</span>, value: name, increment: !!increment });
  }
  (tokenizer <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).locator = locator;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compiler</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#x3C;&#x3C;<span class="hljs-subst">${node.value}</span>>><span class="hljs-subst">${node.increment ? "+" : ""}</span>`</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRemarkParser</span>(<span class="hljs-params">parser</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(
    parser &#x26;&#x26;
      parser.prototype &#x26;&#x26;
      parser.prototype.inlineTokenizers &#x26;&#x26;
      parser.prototype.inlineTokenizers.break &#x26;&#x26;
      parser.prototype.inlineTokenizers.break.locator
  );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRemarkCompiler</span>(<span class="hljs-params">compiler</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(compiler &#x26;&#x26; compiler.prototype);
}
<span class="hljs-comment">// Converr our own "weave" config into a configuration for beautify-js.</span>
<span class="hljs-comment">// Right now we are only handling indent and indent_inner_html.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeJsBeautifyOptions</span>(<span class="hljs-params">config: Config</span>) </span>{
  <span class="hljs-keyword">const</span> {
    indent: indent_size,
    indentInnerHtml: indent_inner_html,
    lineLength: wrap_line_length,
    wrapAttributes: wrap_attributes
  } = config;

  <span class="hljs-keyword">return</span> { indent_size, indent_inner_html, wrap_line_length, wrap_attributes };
}

<span class="hljs-comment">// Convert our own "weave" config into a configuration for prettier.js.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapPrettierOptions</span>(<span class="hljs-params">config: Config</span>): <span class="hljs-title">Partial</span>&#x3C;<span class="hljs-title">prettier</span>.<span class="hljs-title">Options</span>> </span>{
  <span class="hljs-comment">// Create an object of prettier options based on whatever weave options are set.</span>
  <span class="hljs-keyword">const</span> result: prettier.Options = {};

  <span class="hljs-keyword">if</span> (<span class="hljs-string">"lineLength"</span> <span class="hljs-keyword">in</span> config) {
    <span class="hljs-keyword">const</span> lineLength = +config.lineLength;

    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(lineLength)) result.printWidth = lineLength;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-string">"indent"</span> <span class="hljs-keyword">in</span> config) result.tabWidth = config.indent;

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getThemeCss</span>(<span class="hljs-params">theme: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">const</span> themePath = path.join(__filename, <span class="hljs-string">".."</span>, <span class="hljs-string">"themes"</span>, <span class="hljs-string">`<span class="hljs-subst">${theme}</span>.css`</span>);
  <span class="hljs-keyword">const</span> themeCss = <span class="hljs-keyword">await</span> DataUri.promise(themePath);

  <span class="hljs-keyword">return</span> themeCss;
}

<span class="hljs-comment">// Turn the run-time JS support into a Data URL so it can be directly included in the HTML.</span>
<span class="hljs-comment">// This would not be necessary if `rehype-doc` supported inserting JS source in the HTML file.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBrowserJs</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> jsPath = path.join(__filename, <span class="hljs-string">".."</span>, <span class="hljs-string">"themes"</span>, <span class="hljs-string">"modernlit-browser.js"</span>);
  <span class="hljs-keyword">const</span> datauri = <span class="hljs-keyword">await</span> DataUri.promise(jsPath);

  <span class="hljs-keyword">return</span> datauri;
}

<span class="hljs-comment">// Group h2s and everything following them into a section.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h2ToSection</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">ast</span> =></span> {
    <span class="hljs-keyword">const</span> sections: <span class="hljs-built_in">any</span>[] = [];
    <span class="hljs-keyword">let</span> children = sections;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child of ast.children) {
      <span class="hljs-keyword">if</span> (child.tagName &#x26;&#x26; child.tagName === <span class="hljs-string">"h2"</span>)
        sections.push({
          <span class="hljs-keyword">type</span>: <span class="hljs-string">"element"</span>,
          tagName: <span class="hljs-string">"section"</span>,
          children: (children = [])
        });
      children.push(child);
    }

    ast.children = sections;
  };
}

<span class="hljs-comment">// Abstract away the notion of a "fragment heading".</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFragmentHeading</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> node.type === <span class="hljs-string">"heading"</span> &#x26;&#x26; node.depth === <span class="hljs-number">5</span>;
}

<span class="hljs-keyword">interface</span> Fragment {
  name: <span class="hljs-built_in">string</span>;
  codes: <span class="hljs-built_in">any</span>[];
  usedBy?: <span class="hljs-built_in">string</span>[];
}

<span class="hljs-comment">// Traverse the tree, finding fragment headings, and associate them with the following code.</span>
<span class="hljs-comment">// Currently, the logic is that code must follow immediately.</span>
<span class="hljs-comment">// Annotate each code block with an incremental flag, as well as a fragment index.</span>
<span class="hljs-comment">// Return an array of all the fragments, each pointing to one or more code blocks with the same name.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFragments</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">ast, file</span>) =></span> {
    <span class="hljs-keyword">const</span> fragments: Fragment[] = [];

    visit(ast, <span class="hljs-string">"heading"</span>, <span class="hljs-function">(<span class="hljs-params">node, index: <span class="hljs-built_in">number</span>, parent</span>) =></span> {
      <span class="hljs-keyword">if</span> (!isFragmentHeading(node)) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">const</span> code = parent.children[index + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">const</span> name = toString(node);

      <span class="hljs-comment">// The following node must be code; otherwise report and abort.</span>
      <span class="hljs-keyword">if</span> (!code || code.type !== <span class="hljs-string">"code"</span>)
        <span class="hljs-keyword">return</span> file.message(
          <span class="hljs-string">`Fragment heading not followed by code (<span class="hljs-subst">${name}</span>)`</span>,
          node.position.start,
          <span class="hljs-string">"parse:weave"</span>
        );

      <span class="hljs-comment">// See if a fragment with this name has already been encountered.</span>
      <span class="hljs-keyword">let</span> fragmentIndex = fragments.findIndex(
        <span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === name
      );

      <span class="hljs-keyword">if</span> (!node.data) node.data = {};
      <span class="hljs-keyword">if</span> (!node.data.hProperties) node.data.hProperties = {};
      node.data.id = node.data.hProperties.id = slugify(name);

      <span class="hljs-comment">// For new fragments, make a new entry in the fragments array.</span>
      <span class="hljs-keyword">if</span> (fragmentIndex === <span class="hljs-number">-1</span>)
        fragmentIndex = fragments.push({ name, codes: [] }) - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span> node.data.hProperties[<span class="hljs-string">"data-increment"</span>] = node.data.increment = <span class="hljs-literal">true</span>;

      <span class="hljs-comment">// Record the code fragment in the array associatec with the fragment name.</span>
      fragments[fragmentIndex].codes.push(code);
      node.data.hProperties[<span class="hljs-string">"data-index"</span>] = node.data.index = fragmentIndex + <span class="hljs-number">1</span>;
    });

    <span class="hljs-keyword">if</span> (!ast.data) ast.data = {};
    ast.data.fragments = fragments;
  };
}

<span class="hljs-comment">// Travers the MDAST for comments which could be references.</span>
<span class="hljs-comment">// We look for code nodes, under which the highlighting logic should have placed `hChildren` properties,</span>
<span class="hljs-comment">// which we can traverse to find comments, as identified by a potential HTML class of `hljs-comment`.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">codeComments</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">ast, file: VFile</span>) =></span> {
    <span class="hljs-keyword">const</span> fragments: Fragment[] = ast.data.fragments;

    visit(ast, <span class="hljs-string">"code"</span>, <span class="hljs-function">(<span class="hljs-params">mdastNode, index: <span class="hljs-built_in">number</span>, parent</span>) =></span> {
      <span class="hljs-comment">// Get the heading preceding this code block, from which we can derive its name.</span>
      <span class="hljs-keyword">const</span> heading = parent.children[index - <span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (!heading) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"heading does not precede code"</span>);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">const</span> containingFragmentName: <span class="hljs-built_in">string</span> = toString(heading).trim();

      <span class="hljs-keyword">const</span> hChildren = mdastNode.data &#x26;&#x26; mdastNode.data.hChildren;

      <span class="hljs-keyword">if</span> (!hChildren) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> hChild of hChildren) {
        visit(hChild, <span class="hljs-string">"element"</span>, <span class="hljs-function"><span class="hljs-params">hastNode</span> =></span> {
          <span class="hljs-keyword">if</span> (
            !hastNode.properties ||
            !hastNode.properties.className ||
            hastNode.properties.className.indexOf(<span class="hljs-string">"hljs-comment"</span>) === <span class="hljs-number">-1</span>
          )
            <span class="hljs-keyword">return</span>;

          <span class="hljs-keyword">const</span> [child] = hastNode.children || [<span class="hljs-literal">undefined</span>];

          <span class="hljs-keyword">if</span> (!child || child.type !== <span class="hljs-string">"text"</span>)
            <span class="hljs-keyword">return</span> (
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"poblem"</span>, child) ||
              file.message(
                <span class="hljs-string">`Malformed reference`</span>,
                mdastNode.position.start,
                <span class="hljs-string">"parse:weave"</span>
              )
            );

          <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/&#x3C;&#x3C;.*>>/</span>.test(child.value)) <span class="hljs-keyword">return</span>;

          <span class="hljs-keyword">const</span> name = (child.value = child.value.replace(<span class="hljs-regexp">/^.*&#x3C;&#x3C;|>>.*$/g</span>, <span class="hljs-string">""</span>));
          <span class="hljs-keyword">const</span> fragmentIndex = fragments.findIndex(
            <span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === name
          );

          <span class="hljs-keyword">if</span> (!hastNode.properties) hastNode.properties = {};
          <span class="hljs-keyword">if</span> (!hastNode.properties.className)
            hastNode.properties.className = [];

          hastNode.properties.className.push(<span class="hljs-string">"ml-comment-link"</span>);

          <span class="hljs-keyword">if</span> (fragmentIndex === <span class="hljs-number">-1</span>) {
            hastNode.properties[<span class="hljs-string">"data-index"</span>] = <span class="hljs-string">"MISSING"</span>;
            <span class="hljs-keyword">return</span> file.message(
              <span class="hljs-string">`Reference to unknown fragment '<span class="hljs-subst">${name}</span>'`</span>,
              mdastNode.position.start,
              <span class="hljs-string">"parse:weave"</span>
            );
          }

          hastNode.properties[<span class="hljs-string">"data-index"</span>] = fragmentIndex + <span class="hljs-number">1</span>;

          <span class="hljs-keyword">const</span> fragment = fragments[fragmentIndex];
          <span class="hljs-keyword">if</span> (!fragment.usedBy) fragment.usedBy = [];
          fragment.usedBy.push(containingFragmentName);

          hastNode.children[<span class="hljs-number">0</span>] = {
            <span class="hljs-keyword">type</span>: <span class="hljs-string">"element"</span>,
            tagName: <span class="hljs-string">"a"</span>,
            properties: { href: <span class="hljs-string">"#"</span> + slugify(name) },
            children: [child]
          };
        });
      }
    });
  };
}

<span class="hljs-comment">// Create a mermaid representation of the graph structure of the "web".</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeGraph</span>(<span class="hljs-params">fragments: Fragment[]</span>) </span>{
  <span class="hljs-keyword">let</span> s: <span class="hljs-built_in">string</span> = <span class="hljs-string">"graph LR;\n"</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; fragments.length; i++) {
    <span class="hljs-keyword">const</span> { name, usedBy = [] } = fragments[i];

    s += <span class="hljs-string">`N<span class="hljs-subst">${i}</span>[<span class="hljs-subst">${name}</span>];\n`</span>;
    s += <span class="hljs-string">`click N<span class="hljs-subst">${i}</span> "#<span class="hljs-subst">${slugify(name)}</span>";\n`</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> user of usedBy) {
      <span class="hljs-keyword">const</span> usedByIndex = fragments.findIndex(
        <span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === user
      );
      s += <span class="hljs-string">`N<span class="hljs-subst">${usedByIndex}</span> --> N<span class="hljs-subst">${i}</span>;\n`</span>;
      <span class="hljs-comment">//      s += `N${usedByIndex}-- uses --N${i};\n`;</span>
    }
  }

  <span class="hljs-keyword">return</span> s;
}

<span class="hljs-comment">// Given a list of fragment information, which includes usedBy for each fragment, Add relevant notes to the tree.</span>
<span class="hljs-comment">// The plan is to find the fragment titles, then insert the usedBy notation after the code.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertUsedBy</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">ast, file: VFile</span>) =></span> {
    <span class="hljs-keyword">const</span> fragments: Fragment[] = ast.data.fragments;

    visit(ast, <span class="hljs-string">"heading"</span>, <span class="hljs-function">(<span class="hljs-params">node, index: <span class="hljs-built_in">number</span>, parent</span>) =></span> {
      <span class="hljs-keyword">if</span> (!isFragmentHeading(node)) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">const</span> code = parent.children[index + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">const</span> name = toString(node);

      <span class="hljs-keyword">if</span> (!code || code.type !== <span class="hljs-string">"code"</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// See if a fragment with this name has already been encountered.</span>
      <span class="hljs-keyword">const</span> fragment = fragments.find(<span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === name);
      <span class="hljs-keyword">if</span> (!fragment)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"fragment not registere in fragment table"</span>);
      <span class="hljs-keyword">if</span> (!fragment.usedBy || !fragment.usedBy.length) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">let</span> usedBys: <span class="hljs-built_in">any</span>[] = [];
      <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> usedBy of fragment.usedBy) {
        <span class="hljs-keyword">if</span> (!first) usedBys.push({ <span class="hljs-keyword">type</span>: <span class="hljs-string">"text"</span>, value: <span class="hljs-string">"; "</span> });
        first = <span class="hljs-literal">false</span>;
        usedBys.push({
          <span class="hljs-keyword">type</span>: <span class="hljs-string">"link"</span>,
          url: <span class="hljs-string">"#"</span> + slugify(usedBy),
          data: {
            hProperties: {
              className: [<span class="hljs-string">"ml-used-by-link"</span>],
              <span class="hljs-string">"data-index"</span>:
                fragments.findIndex(<span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === usedBy) + <span class="hljs-number">1</span>
            }
          },
          children: [
            {
              <span class="hljs-keyword">type</span>: <span class="hljs-string">"emphasis"</span>,
              children: [
                {
                  <span class="hljs-keyword">type</span>: <span class="hljs-string">"text"</span>,
                  value: usedBy
                }
              ]
            }
          ]
        });
      }

      <span class="hljs-keyword">const</span> usedByNode = {
        <span class="hljs-keyword">type</span>: <span class="hljs-string">"paragraph"</span>,
        children: [
          { <span class="hljs-keyword">type</span>: <span class="hljs-string">"text"</span>, value: <span class="hljs-string">"Used in "</span> },
          ...usedBys,
          { <span class="hljs-keyword">type</span>: <span class="hljs-string">"text"</span>, value: <span class="hljs-string">"."</span> }
        ],
        data: { hProperties: { className: [<span class="hljs-string">"ml-used-by"</span>] } }
      };

      parent.children.splice(index + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, usedByNode);
    });
  };
}

<span class="hljs-comment">// Handle the shortcodes used to isnert a graph, or a list of fragments (GRAPH and TOF).</span>
<span class="hljs-comment">// Right now there are just those two shortcodes.</span>
<span class="hljs-comment">// This dependss on the remark-mermaid plugin running afterwards.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleShortcodes</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">ast, file</span>) =></span> {
    <span class="hljs-keyword">const</span> fragments: Fragment[] = ast.data.fragments;

    visit(ast, <span class="hljs-string">"shortcode"</span>, <span class="hljs-function">(<span class="hljs-params">node, index: <span class="hljs-built_in">number</span>, parent</span>) =></span> {
      <span class="hljs-keyword">switch</span> (node.identifier.toLowerCase()) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"lof"</span>:
          <span class="hljs-keyword">const</span> indices = fragments.map(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =></span> i);

          parent.children[index] = {
            <span class="hljs-keyword">type</span>: <span class="hljs-string">"list"</span>,
            children: indices
              .sort(<span class="hljs-function">(<span class="hljs-params">i1, i2</span>) =></span>
                fragments[i1].name
                  .toLowerCase()
                  .localeCompare(fragments[i2].name.toLowerCase())
              )
              .map(<span class="hljs-function"><span class="hljs-params">index</span> =></span> ({
                <span class="hljs-keyword">type</span>: <span class="hljs-string">"listitem"</span>,
                children: [
                  {
                    <span class="hljs-keyword">type</span>: <span class="hljs-string">"link"</span>,
                    url: <span class="hljs-string">"#"</span> + slugify(fragments[index].name),
                    data: {
                      hProperties: {
                        className: [<span class="hljs-string">"ml-lof-link"</span>],
                        <span class="hljs-string">"data-index"</span>: index + <span class="hljs-number">1</span>
                      }
                    },
                    children: [{ <span class="hljs-keyword">type</span>: <span class="hljs-string">"text"</span>, value: fragments[index].name }]
                  }
                ]
              }))
          };
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">"graph"</span>:
          parent.children[index] = {
            <span class="hljs-keyword">type</span>: <span class="hljs-string">"code"</span>,
            value: makeGraph(fragments),
            lang: <span class="hljs-string">"mermaid"</span>
          };
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          file.warning(
            <span class="hljs-string">`Unknown shortcode [[<span class="hljs-subst">${node.identifier}</span>]]`</span>,
            node.position.start,
            <span class="hljs-string">"shortcuts:weave"</span>
          );
      }
    });
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePrettier</span>(<span class="hljs-params"><span class="hljs-keyword">this</span>: <span class="hljs-built_in">any</span></span>) </span>{
  <span class="hljs-keyword">const</span> config: Config = <span class="hljs-keyword">this</span>.data(<span class="hljs-string">"settings"</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (tree, file) => {
    <span class="hljs-keyword">const</span> prettierConfig = <span class="hljs-keyword">await</span> prettier.resolveConfig(file.path);

    visit(tree, <span class="hljs-string">"code"</span>, <span class="hljs-function"><span class="hljs-params">node</span> =></span> {
      <span class="hljs-keyword">const</span> { lang, value } = node;
      <span class="hljs-keyword">const</span> filepath = <span class="hljs-string">`foo.<span class="hljs-subst">${lang}</span>`</span>;

      <span class="hljs-keyword">if</span> (lang === <span class="hljs-string">"html"</span> || lang === <span class="hljs-string">"mermaid"</span>) <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Combine prettier options from .prettierrc etc., and our options.</span>
        <span class="hljs-keyword">const</span> options = { filepath, ...prettierConfig, ...config.prettier };

        <span class="hljs-keyword">const</span> result = prettier.format(value, options);

        <span class="hljs-keyword">if</span> (result) node.value = result;
        <span class="hljs-keyword">else</span>
          file.message(
            <span class="hljs-string">`Formatting failed for <span class="hljs-subst">${lang}</span>`</span>,
            node.position.start,
            <span class="hljs-string">"format-code-block:weave"</span>
          );
      } <span class="hljs-keyword">catch</span> (e) {
        file.message(
          <span class="hljs-string">`No parser available for <span class="hljs-subst">${lang}</span>`</span>,
          node.position.start,
          <span class="hljs-string">"format-code-block:weave"</span>
        );
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Prettier error was"</span>, e);
      }
    });
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beautifyHtml</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">tree</span> =></span>
    visit(
      tree,
      <span class="hljs-string">"code"</span>,
      <span class="hljs-function"><span class="hljs-params">node</span> =></span>
        node.langCode === <span class="hljs-string">"html"</span> &#x26;&#x26;
        (node.value = jsBeautify.html(
          node.value,
          makeJsBeautifyOptions(tree.dadta.config)
        ))
    );
}

<span class="hljs-comment">// Each theme can be associated with a set of plugins.</span>
<span class="hljs-comment">// Currently, we only have the Tufte theme.</span>
<span class="hljs-keyword">const</span> themePlugins = {
  tufte: [
    h2ToSection,
    [addClasses, { pre: <span class="hljs-string">"code"</span> }],
    [wrap, { wrapper: <span class="hljs-string">"article"</span> }]
  ]
};

<span class="hljs-comment">////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// PROCESS FILE</span>

<span class="hljs-comment">// We are now ready to weave and tangle the modernlit document.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleFile</span>(<span class="hljs-params">file: VFile, initialConfig: Config</span>) </span>{
  <span class="hljs-comment">// Handle prettier options, which may differ from file to file.</span>
  <span class="hljs-keyword">let</span> config = deepmerge(initialConfig, {});

  <span class="hljs-comment">// Do things which are relevant whether weaving, tangling, or both.</span>
  <span class="hljs-keyword">let</span> processor = unified()
    .use({ settings: config })
    .use(parse)
    .use(yaml)
    .use(findFragments);

  <span class="hljs-comment">//  if (!config.only || config.only === "tangle") processor = processor.use(tangle);</span>
  <span class="hljs-keyword">const</span> weaving = !config.only || config.only === <span class="hljs-string">"weave"</span>;
  <span class="hljs-keyword">const</span> tangling = !config.only || config.only === <span class="hljs-string">"tangle"</span>;

  <span class="hljs-keyword">if</span> (tangling) processor = processor.use(<span class="hljs-keyword">await</span> tangle());
  <span class="hljs-keyword">if</span> (weaving) processor = processor.use(<span class="hljs-keyword">await</span> weave());

  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> processor.process(file);
  <span class="hljs-keyword">if</span> (weaving) <span class="hljs-keyword">await</span> writeHtml(result);

  <span class="hljs-comment">// Write out the woven HTML.</span>
  <span class="hljs-comment">// Create the directories if necessary.</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeHtml</span>(<span class="hljs-params">file: VFile</span>) </span>{
    <span class="hljs-comment">// Compute directory and make sure it exists.</span>
    <span class="hljs-keyword">const</span> { outDir } = config;
    <span class="hljs-keyword">let</span> dir = path.dirname(file.path);

    <span class="hljs-keyword">if</span> (outDir) {
      dir = path.isAbsolute(outDir) ? outDir : path.join(dir, outDir);
      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">await</span> exists(dir))) <span class="hljs-keyword">await</span> mkdirpP(dir);
    }

    <span class="hljs-comment">// Compute path and write out file.</span>
    <span class="hljs-keyword">const</span> newPath =
      path.join(dir, path.basename(file.path)).replace(<span class="hljs-regexp">/\.lit\.md$/</span>, <span class="hljs-string">""</span>) +
      <span class="hljs-string">".lit.html"</span>;

    file.info(<span class="hljs-string">`Created <span class="hljs-subst">${newPath}</span>`</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"write-file:weave"</span>);
    toVfile.writeSync({ path: newPath, contents: <span class="hljs-built_in">String</span>(file) });
  }

  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">weave</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> [
      makePrettier,
      beautifyHtml,
      highlight,
      [textr, { plugins: [typographicBase, typographicGuillemets] }],
      shortcodes,
      codeComments,
      insertUsedBy,
      handleShortcodes,
      [mermaid, { simple: <span class="hljs-literal">true</span> }],
      [remarkRehype, { allowDangerousHTML: <span class="hljs-literal">true</span> }],
      <span class="hljs-built_in">console</span>.log(config.theme, themePlugins[config.theme]) ||
        themePlugins[config.theme],
      rehypeStringify,
      raw,
      [
        doc,
        {
          css: [
            <span class="hljs-string">`https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/<span class="hljs-subst">${
              config.style
            }</span>.min.css`</span>,
            <span class="hljs-comment">// This is a monospaced font for code, with ligatures which you will either love or hate.</span>
            <span class="hljs-string">"https://cdn.rawgit.com/tonsky/FiraCode/1.205/distr/fira_code.css"</span>,
            <span class="hljs-comment">// This font looks interesting.</span>
            <span class="hljs-string">"https://fonts.googleapis.com/css?family=Anonymous+Pro:400,400i,700,700i"</span>,
            <span class="hljs-comment">// This is the CSS for the Tufte style.</span>
            <span class="hljs-comment">// See https://edwardtufte.github.io/tufte-css/.</span>
            <span class="hljs-comment">// It also uses an elegant serifed font called et-book.</span>
            <span class="hljs-comment">// See https://github.com/edwardtufte/et-book/</span>
            <span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/tufte-css/1.4/tufte.css"</span>,
            <span class="hljs-keyword">await</span> getThemeCss(config.theme)
          ],
          js: [
            <span class="hljs-comment">// Mermaid</span>
            <span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.1.2/mermaid.min.js"</span>,
            <span class="hljs-keyword">new</span> DataUri().format(
              <span class="hljs-string">".js"</span>,
              <span class="hljs-string">`mermaid.initialize(<span class="hljs-subst">${JSON.stringify({
                startOnLoad: true,
                loadOnStart: true,
                mermaid: { startOnLoad: true, loadOnStart: true }</span>,
                ...config.mermaid
              })})`</span>
            ).content,
            <span class="hljs-keyword">await</span> getBrowserJs()
          ],
          title: config.title
        }
      ]
    ];
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tangle</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> [writeSourceFiles];
  }
}

<span class="hljs-comment">// YAML</span>
<span class="hljs-comment">// Options are provided by YAML block at the top of the file.</span>
<span class="hljs-comment">// They are found in a `yaml` child of the root of the MDAST.</span>
<span class="hljs-comment">// Read them in and update the tree's configuration.</span>
<span class="hljs-keyword">const</span> yaml = [frontmatter, parseYaml];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYaml</span>(<span class="hljs-params"><span class="hljs-keyword">this</span>: { data: (key: <span class="hljs-built_in">string</span>, value?: <span class="hljs-built_in">any</span></span>) => <span class="hljs-title">any</span> }) </span>{
  <span class="hljs-keyword">const</span> config: Config = <span class="hljs-keyword">this</span>.data(<span class="hljs-string">"settings"</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">tree, file: VFile</span>) =></span> {
    <span class="hljs-keyword">const</span> yaml = find(tree, { <span class="hljs-keyword">type</span>: <span class="hljs-string">"yaml"</span> });

    <span class="hljs-keyword">if</span> (yaml) {
      <span class="hljs-keyword">const</span> yamlData = jsYaml.safeLoad(yaml.value);
      <span class="hljs-keyword">if</span> (config.verbose || yamlData.verbose)
        file.info(<span class="hljs-string">"Processed front matter"</span>, yaml.position.start, <span class="hljs-string">":parse"</span>);
      <span class="hljs-comment">// So, where are we supposed to keep this?</span>
      <span class="hljs-comment">// Unified compalines that data cannot be called on a "frozen" processor.</span>
    }
  };
}

<span class="hljs-comment">// Write out tangled files, and sourcemaps.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeSourceFiles</span>(<span class="hljs-params"><span class="hljs-keyword">this</span>: <span class="hljs-built_in">any</span></span>) </span>{
  <span class="hljs-keyword">const</span> {
    outDir,
    mapRoot,
    sourcemap: makeSourcemap,
    newline = <span class="hljs-string">"auto"</span>
  }: Config = <span class="hljs-keyword">this</span>.data(<span class="hljs-string">"settings"</span>);
  <span class="hljs-keyword">const</span> newlineChar = eol(newline);
  <span class="hljs-built_in">console</span>.log({ newlineChar });

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (ast, file) => {
    <span class="hljs-keyword">const</span> fragments: Fragment[] = ast.data.fragments;
    <span class="hljs-built_in">console</span>.assert(!!fragments, <span class="hljs-string">"MDAST must have fragments data"</span>);

    <span class="hljs-comment">// Loop over all the fragments that we want to write out.</span>
    <span class="hljs-keyword">const</span> outputFragments = fragments.filter(<span class="hljs-function">(<span class="hljs-params">{ name }</span>) =></span>
      name.startsWith(<span class="hljs-string">">"</span>)
    );

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fragment of outputFragments) {
      <span class="hljs-keyword">const</span> filename = fragment.name.slice(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">const</span> ext = filename.split(<span class="hljs-string">"."</span>).pop();
      <span class="hljs-keyword">const</span> transclusionChecker = makeTransclusionChecker(ext <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>);
      <span class="hljs-keyword">let</span> outputLineCnt = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">let</span> recursionCount = <span class="hljs-number">0</span>;

      <span class="hljs-comment">// Only certain types have source maps. HTML does not, for example.</span>
      <span class="hljs-keyword">const</span> hasSourcemap =
        makeSourcemap &#x26;&#x26;
        (ext === <span class="hljs-string">"css"</span> ||
          ext == <span class="hljs-string">"scss"</span> ||
          ext == <span class="hljs-string">"sass"</span> ||
          ext == <span class="hljs-string">"ts"</span> ||
          ext == <span class="hljs-string">"js"</span>);

      <span class="hljs-keyword">let</span> dir = file.dirname;
      <span class="hljs-keyword">const</span> sourcemapGenerator = <span class="hljs-keyword">new</span> sourcemap.SourceMapGenerator({
        file: path.join(mapRoot || <span class="hljs-string">""</span>, filename)
      });

      <span class="hljs-keyword">if</span> (outDir) {
        dir = path.isAbsolute(outDir) ? outDir : path.join(dir, outDir);
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">await</span> exists(dir))) <span class="hljs-keyword">await</span> mkdirpP(dir);
      }

      <span class="hljs-keyword">let</span> s = <span class="hljs-string">""</span>;
      addFragmentCodes(fragment);

      <span class="hljs-comment">// Compute path and write out file.</span>
      <span class="hljs-keyword">const</span> newPath = path.join(dir, filename);
      <span class="hljs-keyword">const</span> sourcemapPath = newPath + <span class="hljs-string">".map"</span>;

      <span class="hljs-keyword">if</span> (hasSourcemap) {
        file.info(
          <span class="hljs-string">`Created sourcemap <span class="hljs-subst">${sourcemapPath}</span>`</span>,
          <span class="hljs-literal">null</span>,
          <span class="hljs-string">"write-file:tangle"</span>
        );
        toVfile.writeSync({
          path: sourcemapPath,
          contents: sourcemapGenerator.toString()
        });
        s += <span class="hljs-string">`<span class="hljs-subst">${newlineChar}</span>/*<span class="hljs-subst">${newlineChar}</span>//# sourceMappingURL=<span class="hljs-subst">${filename}</span>.map<span class="hljs-subst">${newlineChar}</span>*/<span class="hljs-subst">${newlineChar}</span>`</span>;
      }

      toVfile.writeSync({ path: newPath, contents: s });
      file.info(<span class="hljs-string">`Created <span class="hljs-subst">${newPath}</span>`</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"write-file:tangle"</span>);

      <span class="hljs-comment">// Add one block to the output.</span>
      <span class="hljs-comment">// Recursively add additional blocks as they are detected.</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFragmentCodes</span>(<span class="hljs-params">fragment: Fragment</span>) </span>{
        <span class="hljs-keyword">let</span> incr = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (recursionCount++ > <span class="hljs-number">1000</span>)
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Tangling is in an infinite loop!"</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> {
          value,
          position: {
            start: { line, column }
          }
        } of fragment.codes || []) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> l of value.split(newlineRe)) {
            s += l + newlineChar;
            line++;

            sourcemapGenerator.addMapping({
              generated: { line: ++outputLineCnt, column: <span class="hljs-number">0</span> },
              source: file.basename,
              original: { line, column }
            });

            <span class="hljs-keyword">const</span> match = transclusionChecker(l);

            <span class="hljs-keyword">if</span> (match) {
              <span class="hljs-keyword">const</span> name = match[<span class="hljs-number">1</span>];
              <span class="hljs-keyword">const</span> fragment = fragments.find(
                <span class="hljs-function"><span class="hljs-params">fragment</span> =></span> fragment.name === name
              );

              <span class="hljs-keyword">if</span> (fragment) addFragmentCodes(fragment);
              <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"While tnagling, could not find fragment"</span>, name);
            }
          }
        }
      }
    }
  };
}

<span class="hljs-comment">////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// COMMAND LINE VERSIONS</span>

<span class="hljs-comment">// Linting. This is available by means of the `--lint` option.</span>
<span class="hljs-keyword">const</span> lintPlugins = [
  <span class="hljs-comment">//  This doesn't work properly, probably because of the two dots.</span>
  <span class="hljs-comment">//  [require("remark-lint-file-extension"), "lit.md"],</span>

  [<span class="hljs-built_in">require</span>(<span class="hljs-string">"remark-lint-maximum-line-length"</span>), <span class="hljs-number">100</span>],
  <span class="hljs-comment">//  require("remark-lint-no-consecutive-blank-lines"),</span>
  [<span class="hljs-built_in">require</span>(<span class="hljs-string">"remark-lint-code-block-style"</span>), <span class="hljs-string">"fenced"</span>],
  [<span class="hljs-built_in">require</span>(<span class="hljs-string">"remark-lint-fenced-code-flag"</span>), { allowEmpty: <span class="hljs-literal">false</span> }],
  [<span class="hljs-built_in">require</span>(<span class="hljs-string">"remark-lint-fenced-code-marker"</span>), <span class="hljs-string">"`"</span>]
];

<span class="hljs-comment">// Weaving from command line.</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">modernlit</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Default.</span>
  <span class="hljs-keyword">const</span> config = {
    indentInnerHtml: <span class="hljs-literal">true</span>,
    mermaid: {},
    style: <span class="hljs-string">"github"</span>,
    theme: <span class="hljs-string">"tufte"</span>,
    title: <span class="hljs-string">"modernlit"</span>,
    wrapAttributes: <span class="hljs-string">"auto"</span>
  } <span class="hljs-keyword">as</span> Config;

  <span class="hljs-keyword">const</span> minimistConfig = { <span class="hljs-built_in">boolean</span>: <span class="hljs-literal">true</span> };
  <span class="hljs-keyword">const</span> options = minimist(process.argv.slice(<span class="hljs-number">2</span>), minimistConfig) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;
  <span class="hljs-keyword">const</span> files = options._;

  rc(<span class="hljs-string">"modernlit"</span>, config, options);
  <span class="hljs-keyword">const</span> configs = config[<span class="hljs-string">"configs"</span>];

  <span class="hljs-keyword">const</span> { help, recurse, quiet, lint, watch, verbose } = config;

  <span class="hljs-keyword">if</span> (help) usage(), process.exit(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span> (!files || !files.length)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"No files specified."</span>), process.exit(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span> (verbose &#x26;&#x26; configs) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Using config files"</span>, configs.join(<span class="hljs-string">", "</span>));

  <span class="hljs-keyword">const</span> globPatterns = files.map(<span class="hljs-function"><span class="hljs-params">file</span> =></span> <span class="hljs-string">`<span class="hljs-subst">${file}</span>/**/*.lit.md`</span>);
  <span class="hljs-keyword">const</span> globbedFiles = recurse ? <span class="hljs-keyword">await</span> globP(globPatterns.join(<span class="hljs-string">" "</span>)) : files;

  <span class="hljs-comment">// Handle the specified files or directories right now, and log results if not quiet.</span>
  <span class="hljs-keyword">const</span> vfiles: VFile[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file of globbedFiles) vfiles.push(<span class="hljs-keyword">await</span> handle(file));
  <span class="hljs-keyword">if</span> (!quiet) <span class="hljs-built_in">console</span>.error(reporter(vfiles));

  <span class="hljs-comment">// Watch for changes if that was requested.</span>
  <span class="hljs-keyword">if</span> (watch)
    chokidar
      .watch(recurse ? globPatterns : files, { ignoreInitial: <span class="hljs-literal">true</span> })
      .on(<span class="hljs-string">"all"</span>, <span class="hljs-keyword">async</span> (event, path) => {
        <span class="hljs-keyword">if</span> (event === <span class="hljs-string">"add"</span> || event === <span class="hljs-string">"change"</span>) {
          <span class="hljs-keyword">const</span> vfile = <span class="hljs-keyword">await</span> handle(path);
          <span class="hljs-keyword">if</span> (!quiet) <span class="hljs-built_in">console</span>.error(reporter(vfile));
        }
      });

  <span class="hljs-comment">// Handle s single file, either initially or when watch triggers.</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">VFile</span>> </span>{
    <span class="hljs-keyword">const</span> vfile = toVfile.readSync({ path });

    <span class="hljs-keyword">if</span> (lint)
      <span class="hljs-keyword">await</span> remark()
        .use({ plugins: lintPlugins })
        .process(vfile);

    <span class="hljs-keyword">await</span> handleFile(vfile, config);

    <span class="hljs-keyword">return</span> vfile;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">usage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Usage:"</span>);
    <span class="hljs-built_in">console</span>.log();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"modernlit  [options] source-file ..."</span>);
    <span class="hljs-built_in">console</span>.log();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Options"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --help              Display this message"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --indent=           Width of indentation"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --lineLength=       Maximum line lnegth"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --lint              Check input files"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --mermaid.theme=    Theme for mermaid diagrams"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --outDir=           Location of output files"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --quiet             Suppress soutput"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --only=weave,tangle"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --prettier.semi            Insert semi-colons (true)"</span>);
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">"  --prettier.singleQuote     Use single quotes instead of double quotes (false)"</span>
    );
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">"  --prettier.trailingComma   Add trailing commas (none, es5, all)"</span>
    );
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">"  --prettier.bracketSpacing  Print spaces between brackets in object literals (false)"</span>
    );
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --recurse           Process files in subdirectories"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --style=            Style for langauge highlighting"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --theme=            Theme (CSS) for weave output"</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --title=            HTML title"</span>);
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">"  --watch             Watch for file changes and re-weave or re-tangle"</span>
    );
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"  --verbose           Print additional information"</span>);
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">"  --wrapAttributes    Wrap HTML attributes (auto, force, etc.)"</span>
    );
  }
}

<span class="hljs-comment">////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// SOURCE MAPS</span>

<span class="hljs-comment">// Rewrite a sourcemap as generated by tsc to reflect the mapping from the modernlit input to TypeScript.</span>
<span class="hljs-comment">// That is the most common case, but actually this script doesn't care.</span>
<span class="hljs-comment">// For example, it could by applied to a sourcemap created by SCSS.</span>
<span class="hljs-comment">// Takes the "input" sourcemap on stdin, and outputs the remapped sourcemap on stdout.</span>
<span class="hljs-comment">// This routine is used by the `mlsourcemap` command installed into `node_mobulds/.bin`.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Usage:</span>
<span class="hljs-comment">// ```</span>
<span class="hljs-comment">// cat foo.js.map | mlsourcem foo.ts.map > foo.js.map</span>
<span class="hljs-comment">// cat foo.css.map | mlsourcem foo.scss.map > foo.css.map</span>
<span class="hljs-comment">// ```</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mlsourcemap</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Get the input sourcemap (e.g., foo.js.map) from stdin.</span>
  <span class="hljs-keyword">const</span> inputSourcemapJson = fs.readFileSync(<span class="hljs-string">"/dev/stdin"</span>, <span class="hljs-string">"utf-8"</span>);
  <span class="hljs-keyword">const</span> inputSourcemap = <span class="hljs-built_in">JSON</span>.parse(inputSourcemapJson);

  <span class="hljs-comment">// The the modernlit sourcemap (e.g. foo.ts.map) from the first argument.</span>
  <span class="hljs-keyword">const</span> [, , mlSourcemapName] = process.argv;
  <span class="hljs-keyword">const</span> mlSourcemapJson = fs.readFileSync(mlSourcemapName, <span class="hljs-string">"utf-8"</span>);
  <span class="hljs-keyword">const</span> mlSourcemap = <span class="hljs-built_in">JSON</span>.parse(mlSourcemapJson);

  <span class="hljs-comment">// Create consumers for both sourcemaps.</span>
  <span class="hljs-keyword">const</span> inputConsumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> sourcemap.SourceMapConsumer(inputSourcemap);
  <span class="hljs-keyword">const</span> mlConsumer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> sourcemap.SourceMapConsumer(mlSourcemap);

  <span class="hljs-comment">// Create a "generator" based on the input sourcemap consumer.</span>
  <span class="hljs-keyword">const</span> generator = sourcemap.SourceMapGenerator.fromSourceMap(inputConsumer);

  <span class="hljs-comment">// "Apply" the modernlit sourcemap, and output it.</span>
  generator.applySourceMap(mlConsumer);
  <span class="hljs-built_in">console</span>.log(generator.toString());
}

<span class="hljs-keyword">export</span> { modernlit, handleFile, mlsourcemap };
</code></pre></section>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.1.2/mermaid.min.js"></script>
<script src="data:application/javascript;base64,bWVybWFpZC5pbml0aWFsaXplKHsic3RhcnRPbkxvYWQiOnRydWUsImxvYWRPblN0YXJ0Ijp0cnVlLCJtZXJtYWlkIjp7InN0YXJ0T25Mb2FkIjp0cnVlLCJsb2FkT25TdGFydCI6dHJ1ZX19KQ=="></script>
<script src="data:application/javascript;base64,ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigKICAiRE9NQ29udGVudExvYWRlZCIsICgpID0+CiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZePSIjIl0nKS5mb3JFYWNoKAogICAgICBhbmNob3IgPT4KICAgICAgICBhbmNob3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7CiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CgogICAgICAgICAgdmFyIGVsdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7CgogICAgICAgICAgZWx0LnNjcm9sbEludG9WaWV3KHtiZWhhdmlvcjogJ3Ntb290aCd9KTsKICAgICAgICAgIGVsdC5jbGFzc0xpc3QuYWRkKCJoaWdobGlnaHQiKTsKICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGVsdC5jbGFzc0xpc3QucmVtb3ZlKCJoaWdobGlnaHQiKSwgMjAwMCk7CiAgICAgICAgfSkpKTsK"></script>
</body>
</html>
